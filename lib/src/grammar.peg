%{
  import 'dart:core';
  import 'dart:convert';
  import 'data.dart';
  import 'name_addr_header.dart';
  import 'uri.dart';

}%

{
  var startRule;
  var data = ParsedData();

  int parseInt(str){
    return int.tryParse(str) ?? null;
  }

  double parseFloat(str){
    return double.parse(str);
  }

  String decodeURIComponent(str){
    return Uri.decodeComponent(str);
  }

  parse(input, startRule) {
      var parseFunctions = { 
        "CRLF": _parse_CRLF,
        "DIGIT": _parse_DIGIT, 
        "ALPHA": _parse_ALPHA, 
        "HEXDIG": _parse_HEXDIG, 
        "WSP": _parse_WSP, 
        "OCTET": _parse_OCTET, 
        "DQUOTE": _parse_DQUOTE, 
        "SP": _parse_SP, 
        "HTAB": _parse_HTAB, 
        "alphanum": _parse_alphanum, 
        "reserved": _parse_reserved, 
        "unreserved": _parse_unreserved,
        "mark": _parse_mark, 
        "escaped": _parse_escaped, 
        "LWS": _parse_LWS, 
        "SWS": _parse_SWS,
        "HCOLON": _parse_HCOLON, 
        "TEXT_UTF8_TRIM": _parse_TEXT_UTF8_TRIM, 
        "TEXT_UTF8char": _parse_TEXT_UTF8char,
        "UTF8_NONASCII": _parse_UTF8_NONASCII, 
        "UTF8_CONT": _parse_UTF8_CONT, 
        "LHEX": parse_LHEX,
        "token": _parse_token, 
        "token_nodot": _parse_token_nodot, 
        "separators": parse_separators,
        "word": _parse_word, 
        "STAR": _parse_STAR,
        "SLASH": _parse_SLASH,
        "EQUAL": _parse_EQUAL, 
        "LPAREN": _parse_LPAREN, 
        "RPAREN": _parse_RPAREN, 
        "RAQUOT": _parse_RAQUOT, 
        "LAQUOT": _parse_LAQUOT,
        "COMMA": _parse_COMMA,
        "SEMI": _parse_SEMI, 
        "COLON": _parse_COLON, 
        "LDQUOT": _parse_LDQUOT, 
        "RDQUOT": _parse_RDQUOT, 
        "comment": parse_comment,
        "ctext": _parse_ctext, 
        "quoted_string": _parse_quoted_string,
        "quoted_string_clean": _parse_quoted_string_clean,
        "qdtext": _parse_qdtext, 
        "quoted_pair": _parse_quoted_pair, 
        "SIP_URI_noparams": _parse_SIP_URI_noparams,
        "SIP_URI": _parse_SIP_URI,
        "uri_scheme": _parse_uri_scheme, 
        "uri_scheme_sips": _parse_uri_scheme_sips,
        "uri_scheme_sip": _parse_uri_scheme_sip, 
        "userinfo": _parse_userinfo,
        "user": _parse_user, 
        "user_unreserved": _parse_user_unreserved,
        "password": _parse_password,
        "hostport": _parse_hostport, 
        "host": _parse_host, 
        "hostname": _parse_hostname, 
        "domainlabel": _parse_domainlabel, 
        "toplabel": _parse_toplabel,
        "IPv6reference": _parse_IPv6reference,
        "IPv6address": _parse_IPv6address, 
        "h16": _parse_h16, 
        "ls32": _parse_ls32, 
        "IPv4address": _parse_IPv4address,
        "dec_octet": _parse_dec_octet, 
        "port": _parse_port, 
        "uri_parameters": _parse_uri_parameters, 
        "uri_parameter": _parse_uri_parameter, 
        "transport_param": _parse_transport_param,
        "user_param": _parse_user_param, 
        "method_param": _parse_method_param, 
        "ttl_param": _parse_ttl_param, 
        "maddr_param": _parse_maddr_param, 
        "lr_param": _parse_lr_param, 
        "other_param": _parse_other_param, 
        "pname": _parse_pname, 
        "pvalue": _parse_pvalue, 
        "paramchar": _parse_paramchar, 
        "param_unreserved": _parse_param_unreserved, 
        "headers": _parse_headers, 
        "header": _parse_header, 
        "hname": _parse_hname, 
        "hvalue": _parse_hvalue,
        "hnv_unreserved": _parse_hnv_unreserved,
        "Request_Response": parse_Request_Response,
        "Request_Line": _parse_Request_Line, 
        "Request_URI": _parse_Request_URI,
        "absoluteURI": _parse_absoluteURI,
        "hier_part": _parse_hier_part, 
        "net_path": _parse_net_path, 
        "abs_path": _parse_abs_path,
        "opaque_part": _parse_opaque_part, 
        "uric": _parse_uric, 
        "uric_no_slash": _parse_uric_no_slash,
        "path_segments": _parse_path_segments,
        "segment": _parse_segment,
        "param": _parse_param, 
        "pchar": _parse_pchar, 
        "scheme": _parse_scheme, 
        "authority": _parse_authority,
        "srvr": _parse_srvr, 
        "reg_name": _parse_reg_name, 
        "query": _parse_query, 
        "SIP_Version": _parse_SIP_Version,
        "INVITEm": _parse_INVITEm, 
        "ACKm": _parse_ACKm, 
        "OPTIONSm": _parse_OPTIONSm, 
        "BYEm": _parse_BYEm, 
        "CANCELm": _parse_CANCELm, 
        "REGISTERm": _parse_REGISTERm, 
        "SUBSCRIBEm": _parse_SUBSCRIBEm, 
        "NOTIFYm": _parse_NOTIFYm, 
        "REFERm": _parse_REFERm, 
        "Method": _parse_Method,
        "Status_Line": _parse_Status_Line,
        "Status_Code": _parse_Status_Code, 
        "extension_code": _parse_extension_code,
        "Reason_Phrase": _parse_Reason_Phrase,
        "Allow_Events": parse_Allow_Events,
        "Call_ID": parse_Call_ID,
        "Contact": parse_Contact,
        "contact_param": _parse_contact_param, 
        "name_addr": _parse_name_addr,
        "display_name": _parse_display_name,
        "contact_params": _parse_contact_params, 
        "c_p_q": _parse_c_p_q, 
        "c_p_expires": _parse_c_p_expires, 
        "delta_seconds": _parse_delta_seconds, 
        "qvalue": _parse_qvalue, 
        "generic_param": _parse_generic_param, 
        "gen_value": _parse_gen_value, 
        "Content_Disposition": parse_Content_Disposition,
        "disp_type": _parse_disp_type, 
        "disp_param": _parse_disp_param, 
        "handling_param": _parse_handling_param, 
        "Content_Encoding": parse_Content_Encoding,
        "Content_Length": parse_Content_Length,
        "Content_Type": parse_Content_Type,
        "media_type": _parse_media_type, 
        "m_type": _parse_m_type, 
        "discrete_type": _parse_discrete_type, 
        "composite_type": _parse_composite_type, 
        "extension_token": _parse_extension_token, 
        "x_token": _parse_x_token, 
        "m_subtype": _parse_m_subtype,
        "m_parameter": _parse_m_parameter, 
        "m_value": _parse_m_value, 
        "CSeq": parse_CSeq,
        "CSeq_value": _parse_CSeq_value, 
        "Expires": parse_Expires,
        "Event": parse_Event,
        "event_type": _parse_event_type,
        "From": parse_From,
        "from_param": _parse_from_param,
        "tag_param": _parse_tag_param, 
        "Max_Forwards": parse_Max_Forwards,
        "Min_Expires": parse_Min_Expires,
        "Name_Addr_Header": parse_Name_Addr_Header,
        "Proxy_Authenticate": parse_Proxy_Authenticate,
        "challenge": _parse_challenge, 
        "other_challenge": _parse_other_challenge, 
        "auth_param": _parse_auth_param,
        "digest_cln": _parse_digest_cln,
        "realm": _parse_realm,
        "realm_value": _parse_realm_value,
        "domain": _parse_domain,
        "URI": _parse_URI,
        "nonce": _parse_nonce, 
        "nonce_value": _parse_nonce_value, 
        "opaque": _parse_opaque, 
        "stale": _parse_stale, 
        "algorithm": _parse_algorithm, 
        "qop_options": _parse_qop_options, 
        "qop_value": _parse_qop_value, 
        "Proxy_Require": parse_Proxy_Require,
        "Record_Route": parse_Record_Route,
        "rec_route": _parse_rec_route, 
        "Reason": parse_Reason,
        "reason_param": _parse_reason_param, 
        "reason_cause": _parse_reason_cause, 
        "Require": parse_Require,
        "Route": parse_Route,
        "route_param": _parse_route_param, 
        "Subscription_State": parse_Subscription_State,
        "substate_value": _parse_substate_value,
        "subexp_params": _parse_subexp_params, 
        "event_reason_value": _parse_event_reason_value, 
        "Subject": parse_Subject,
        "Supported": parse_Supported,
        "To": parse_To,
        "to_param": _parse_to_param, 
        "Via": parse_Via,
        "via_param": _parse_via_param, 
        "via_params": _parse_via_params, 
        "via_ttl": _parse_via_ttl, 
        "via_maddr": _parse_via_maddr, 
        "via_received": _parse_via_received, 
        "via_branch": _parse_via_branch, 
        "response_port": _parse_response_port,
        "sent_protocol": _parse_sent_protocol,
        "protocol_name": _parse_protocol_name, 
        "transport": _parse_transport,
        "sent_by": _parse_sent_by, 
        "via_host": _parse_via_host, 
        "via_port": _parse_via_port, 
        "ttl": _parse_ttl, 
        "WWW_Authenticate": parse_WWW_Authenticate,
        "Session_Expires": parse_Session_Expires,
        "s_e_expires": _parse_s_e_expires, 
        "s_e_params": _parse_s_e_params, 
        "s_e_refresher": _parse_s_e_refresher, 
        "extension_header": parse_extension_header,
        "header_value": _parse_header_value, 
        "message_body": parse_message_body,
        "uuid_URI": parse_uuid_URI,
        "uuid": _parse_uuid,
        "hex4": _parse_hex4, 
        "hex8": _parse_hex8, 
        "hex12": _parse_hex12, 
        "Refer_To": parse_Refer_To,
        "Replaces": parse_Replaces,
        "call_id": _parse_call_id,
        "replaces_param": _parse_replaces_param,
        "to_tag": _parse_to_tag,
        "from_tag": _parse_from_tag,
        "early_flag": _parse_early_flag
      };
      if (input == null) {
        throw ArgumentError('text: $input');
      }
      _input = _toCodePoints(input);
      _inputLen = _input.length;
      reset(0);

      if (startRule != null) {
          if (parseFunctions[startRule] == null) {
            throw ArgumentError("Invalid rule name: " + startRule + ".");
          }
        } else {
          startRule = "CRLF";
        }
      this.startRule = startRule;
      return parseFunctions[startRule]();
    }
}

## ABNF BASIC

CRLF    <- "\r\n"
DIGIT   <- [0-9]
ALPHA   <- [a-zA-Z]
HEXDIG  <- [0-9a-fA-F]
WSP     <- SP / HTAB
OCTET   <- [\u0000-\u00FF]
DQUOTE  <- ["]
SP      <- " "
HTAB    <- "\t"


## BASIC RULES

alphanum    <- [a-zA-Z0-9]
reserved    <- ";" / "/" / "?" / ":" / "@" / "&" / "=" / "+" / "$" / ","
unreserved  <- alphanum / mark
mark        <- "-" / "_" / "." / "!" / "~" / "*" / "'" / "(" / ")"
escaped     <- escaped: ("%" HEXDIG HEXDIG) {return escaped.join(''); }

#/* RFC3261 25: A recipient MAY replace any linear white space with a single SP
# * before interpreting the field value or forwarding the message downstream
# */
LWS <- ( WSP* CRLF )? WSP+ {return " "; }

SWS <- LWS?

HCOLON  <- ( SP / HTAB )* ":" SWS {return ':'; }

TEXT_UTF8_TRIM  <- TEXT_UTF8char+ ( LWS* TEXT_UTF8char)* {
                    return _text(); }

TEXT_UTF8char   <- [\x21-\x7E] / UTF8_NONASCII

UTF8_NONASCII   <- [\xC0-\xDF] UTF8_CONT
                  / [\xE0-\xEF] UTF8_CONT UTF8_CONT
                  / [\xF0-\xF7] UTF8_CONT UTF8_CONT UTF8_CONT
                  / [\xF8-\xFb] UTF8_CONT UTF8_CONT UTF8_CONT UTF8_CONT
                  / [\xFC-\xFD] UTF8_CONT UTF8_CONT UTF8_CONT UTF8_CONT UTF8_CONT

UTF8_CONT       <- [\x80-\xBF]

LHEX            <- DIGIT / [\x61-\x66]

token           <- (alphanum / "-" / "." / "!" / "%" / "*"
                  / "_" / "+" / "`" / "'" / "~" )+ {
                  return _text(); }

token_nodot     <- ( alphanum / "-"  / "!" / "%" / "*"
                  / "_" / "+" / "`" / "'" / "~" )+ {
                  return _text(); }

separators      <- "(" / ")" / "<" / ">" / "@" / "," / ";" / ":" / "\\"
                  / DQUOTE / "/" / "[" / "]" / "?" / "=" / "{" / "}"
                  / SP / HTAB

word            <- (alphanum / "-" / "." / "!" / "%" / "*" /
                  "_" / "+" / "`" / "'" / "~" /
                  "(" / ")" / "<" / ">" /
                  ":" / "\\" / DQUOTE /
                  "/" / "[" / "]" / "?" /
                  "{" / "}" )+ {
                  return _text(); }

STAR        <- SWS "*" SWS   {return "*"; }
SLASH       <- SWS "/" SWS   {return "/"; }
EQUAL       <- SWS "=" SWS   {return "="; }
LPAREN      <- SWS "(" SWS   {return "("; }
RPAREN      <- SWS ")" SWS   {return ")"; }
RAQUOT      <- ">" SWS       {return ">"; }
LAQUOT      <- SWS "<"       {return "<"; }
COMMA       <- SWS "," SWS   {return ","; }
SEMI        <- SWS ";" SWS   {return ";"; }
COLON       <- SWS ":" SWS   {return ":"; }
LDQUOT      <- SWS DQUOTE    {return "\""; }
RDQUOT      <- DQUOTE SWS    {return "\""; }

comment     <- LPAREN (ctext / quoted_pair / comment)* RPAREN

ctext       <- [\x21-\x27] / [\x2A-\x5B] / [\x5D-\x7E] / UTF8_NONASCII / LWS

quoted_string <- SWS DQUOTE ( qdtext / quoted_pair )* DQUOTE {
                  return _text(); }

quoted_string_clean <- SWS DQUOTE ( qdtext / quoted_pair )* DQUOTE {
                  var trimmed = _text().trim();
                  $$ = trimmed
                      .substring(1, trimmed.length - 1) /// remove outer quotes
                      .replaceAll("\\([\x00-\x09\x0b-\x0c\x0e-\x7f])", '\$1'); } ## unquote contents

qdtext  <- LWS / "\x21" / [\x23-\x5B] / [\x5D-\x7E] / UTF8_NONASCII

quoted_pair <- "\\" ( [\x00-\x09] / [\x0B-\x0C] / [\x0E-\x7F] )


##=======================
## SIP URI
##=======================

SIP_URI_noparams  <- uri_scheme ":"  userinfo? hostport {
                    try {
                        data.uri = URI(data.scheme, data.user, data.host, data.port);
                        data.scheme = null;
                        data.user = null;
                        data.host = null;
                        data.host_type = null;
                        data.port = null;
                      } catch(e) {
                        $$ = -1;
                      }}

SIP_URI         <- uri_scheme ":" userinfo? hostport uri_parameters headers? {
                    var header;
                    try {
                        data.uri = URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                        data.scheme = null;
                        data.user = null;
                        data.host = null;
                        data.host_type = null;
                        data.port = null;
                        data.uri_params = null;

                        if (startRule == 'SIP_URI') {
                           $$ = data.uri;
                        }
                      } catch(e) {
                        $$ == -1;
                      }}

uri_scheme      <- uri_scheme_sips / uri_scheme_sip

uri_scheme_sips <- scheme: "sips"i {
                    data.scheme = scheme.toLowerCase(); }

uri_scheme_sip <- scheme: "sip"i {
                    data.scheme = scheme.toLowerCase(); }

userinfo        <- plus: "+"? user: ( user) (":" password)? "@" {
                    data.user = (plus !=null ? plus : '') + decodeURIComponent(user.join(''));
                    return data.user;
                  }

user            <- ( user_unreserved / unreserved / escaped )+

user_unreserved <- "&" / "=" / "+" / "$" / "," / ";" / "?" / "/"

password        <- ( unreserved / escaped / "&" / "=" / "+" / "$" / "," )* {
                    data.password = _text();
                    $$ = data.password;
                  }

hostport        <- host ( ":" port )?

host            <- ( hostname / IPv4address / IPv6reference / hosttoken) {
                    $$ =  $1; }

## 'hostname' grammar is relaxed from RFC 3261:
## 'domainlabel' and 'toplabel' can end with dash or hypen

hostname        <- (( domainlabel "." )* toplabel  "." ?) {
                  data.host = _text().toLowerCase();
                  data.host_type = 'domain';
                  var result = {};
                  result['host_type'] = data.host_type;
                  result['host'] = data.host;
                  $$ =  result; }

## hello <sip:asterisk@8c2d06b92042:5060;transport=ws>
hosttoken       <- token_nodot {
                  data.host = _text();
                  data.host_type = 'domain';
                  var result = {};
                  result['host_type'] = data.host_type;
                  result['host'] = data.host;
                  $$ =  result; }

domainlabel     <- alphanum ( alphanum / "-" / "_" )*

toplabel        <- ALPHA ( alphanum / "-" / "_" )*

IPv6reference   <- "[" IPv6address "]" {
                  data.host = _text();
                  data.host_type = 'IPv6';
                  var result = {};
                  result['host_type'] = data.host_type;
                  result['host'] = data.host;
                  $$ =  result;}

IPv6address     <- ( h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" ls32
                  / "::" h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" ls32
                  / "::" h16 ":" h16 ":" h16 ":" h16 ":" ls32
                  / "::" h16 ":" h16 ":" h16 ":" ls32
                  / "::" h16 ":" h16 ":" ls32
                  / "::" h16 ":" ls32
                  / "::" ls32
                  / "::" h16
                  / h16 "::" h16 ":" h16 ":" h16 ":" h16 ":" ls32
                  / h16 (":" h16)? "::" h16 ":" h16 ":" h16 ":" ls32
                  / h16 (":" h16)? (":" h16)? "::" h16 ":" h16 ":" ls32
                  / h16 (":" h16)? (":" h16)? (":" h16)? "::" h16 ":" ls32
                  / h16 (":" h16)? (":" h16)? (":" h16)? (":" h16)? "::" ls32
                  / h16 (":" h16)? (":" h16)? (":" h16)? (":" h16)? (":" h16)? "::" h16
                  / h16 (":" h16)? (":" h16)? (":" h16)? (":" h16)? (":" h16)? (":" h16)? "::"
                  ) {
                  data.host = _text();
                  data.host_type = 'IPv6';
                  var result = {};
                  result['host_type'] = data.host_type;
                  result['host'] = data.host;
                  $$ =  result;}


h16             <- HEXDIG HEXDIG? HEXDIG? HEXDIG?

ls32            <- ( h16 ":" h16 ) / IPv4address


IPv4address     <- dec_octet "." dec_octet "." dec_octet "." dec_octet {
                  data.host = _text();
                  data.host_type = 'IPv4';
                  var result = {};
                  result['host_type'] = data.host_type;
                  result['host'] = data.host;
                  $$ =  result;}

dec_octet       <- "25" [\x30-\x35]          ## 250-255
                / "2" [\x30-\x34] DIGIT     ## 200-249
                / "1" DIGIT DIGIT           ## 100-199
                / [\x31-\x39] DIGIT         ## 10-99
                / DIGIT                     ## 0-9

port            <- port: (DIGIT ? DIGIT ? DIGIT ? DIGIT ? DIGIT ?) {
                    port = parseInt(_text());
                    data.port = port;
                    $$ = port; }

## URI PARAMETERS

uri_parameters    <- ( ";" uri_parameter)*

uri_parameter     <- transport_param / user_param / method_param
                    / ttl_param / maddr_param / lr_param / other_param

transport_param   <- "transport="i transport: ( "udp"i / "tcp"i / "sctp"i
                    / "tls"i / other_transport) {
                      if(data.uri_params == null) data.uri_params={};
                      data.uri_params['transport'] = transport.toLowerCase(); }

other_transport   <- token

user_param        <- "user="i user: ( "phone"i / "ip"i / other_user) {
                      if(data.uri_params == null) data.uri_params={};
                      data.uri_params['user'] = user.toLowerCase(); }

other_user        <- token

method_param      <- "method="i method: Method {
                      if(data.uri_params == null) data.uri_params = {};
                      data.uri_params['method'] = method; }

ttl_param         <- "ttl="i ttl: ttl {
                      if(data.params == null) data.params = {};
                      data.params['ttl'] = ttl; }

maddr_param       <- "maddr="i maddr: host {
                      if(data.uri_params == null) data.uri_params = {};
                      data.uri_params['maddr'] = maddr; }

lr_param          <- "lr"i ('=' token)? {
                      if(data.uri_params == null) data.uri_params ={ };
                      data.uri_params['lr'] = null; }

other_param       <- param: pname value: ( "=" pvalue )? {
                      if(data.uri_params == null) data.uri_params = {};
                      if ( value != null) {
                        value = value[1];
                      }
                      if(param.toLowerCase() == 'transport')
                        value = value.toLowerCase();
                      data.uri_params[param.toLowerCase()] = value; }

pname             <- pname: paramchar + {return pname.join(''); }

pvalue            <- pvalue: paramchar + {return pvalue.join(''); }

paramchar         <- param_unreserved / unreserved / escaped

param_unreserved  <- "[" / "]" / "/" / ":" / "&" / "+" / "$"


## HEADERS

headers           <- "?" header ( "&" header )*

header            <- hname: hname "=" hvalue: hvalue  {
                      hname = hname.join('').toLowerCase();
                      hvalue = hvalue.join('');
                      if(data.uri_headers == null) data.uri_headers = {};
                      if (data.uri_headers[hname] == null) {
                        data.uri_headers[hname] = [hvalue];
                      } else {
                        data.uri_headers[hname].add(hvalue);
                      }}

hname             <- ( hnv_unreserved / unreserved / escaped )+

hvalue            <- ( hnv_unreserved / unreserved / escaped )*

hnv_unreserved    <- "[" / "]" / "/" / "?" / ":" / "+" / "$"


## FIRST LINE

Request_Response  <- (Status_Line / Request_Line) { $$ = data; }

## REQUEST LINE

Request_Line      <- Method SP Request_URI SP SIP_Version { $$ = data; }

Request_URI       <- SIP_URI / absoluteURI { $$ = data; }

absoluteURI       <- scheme ":" ( hier_part / opaque_part ) { $$ = data; }

hier_part         <- ( net_path / abs_path ) ( "?" query )?

net_path          <- "//" authority  abs_path ?

abs_path          <- "/" path_segments

opaque_part       <- uric_no_slash uric *

uric              <- reserved / unreserved / escaped

uric_no_slash     <- unreserved / escaped / ";" / "?" / ":" / "@" / "&" / "="
                    / "+" / "$" / ","

path_segments     <- segment ( "/" segment )*

segment           <- pchar * ( ";" param )*

param             <- pchar *

pchar             <- unreserved / escaped /
                    ":" / "@" / "&" / "=" / "+" / "$" / ","

scheme            <- ( ALPHA ( ALPHA / DIGIT / "+" / "-" / "." )* ){
                    data.scheme = _text(); }

authority         <- (srvr / reg_name)

srvr              <- ( ( userinfo "@" )? hostport )?

reg_name          <- ( unreserved / escaped / "$" / ","
                    / ";" / ":" / "@" / "&" / "=" / "+" )+

query             <- uric *

SIP_Version       <- "SIP"i "/" DIGIT + "." DIGIT + {
                    data.sip_version = _text(); }

## SIP METHODS

INVITEm           <- "\x49\x4E\x56\x49\x54\x45" ## INVITE in caps

ACKm              <- "\x41\x43\x4B" ## ACK in caps

OPTIONSm          <- "\x4F\x50\x54\x49\x4F\x4E\x53" ## OPTIONS in caps

BYEm              <- "\x42\x59\x45" ## BYE in caps

CANCELm           <- "\x43\x41\x4E\x43\x45\x4C" ## CANCEL in caps

REGISTERm         <- "\x52\x45\x47\x49\x53\x54\x45\x52" ## REGISTER in caps

SUBSCRIBEm        <- "\x53\x55\x42\x53\x43\x52\x49\x42\x45" ## SUBSCRIBE in caps

NOTIFYm           <- "\x4E\x4F\x54\x49\x46\x59" ## NOTIFY in caps

REFERm            <- "\x52\x45\x46\x45\x52" ## REFER in caps

Method            <- ( INVITEm / ACKm / OPTIONSm / BYEm / CANCELm / REGISTERm
                    / SUBSCRIBEm / NOTIFYm / REFERm / extension_method ){
                    data.method_str = _text();
                    $$ =  data.method_str; }

extension_method  <- token


## STATUS LINE

Status_Line     <- SIP_Version SP Status_Code SP Reason_Phrase {
                $$ = data; }

Status_Code     <- status_code: extension_code {
                  data.status_code = parseInt(status_code.join(''));
                  return data.status_code;
                  }

extension_code  <- DIGIT DIGIT DIGIT

Reason_Phrase   <- (reserved / unreserved / escaped
                  / UTF8_NONASCII / UTF8_CONT / SP / HTAB)* {
                  data.reason_phrase = _text();
                  $$ = data.reason_phrase;
                  }


##=======================
## HEADERS
##=======================

## Allow-Events

Allow_Events <- event_type (COMMA event_type)*


## CALL-ID

Call_ID  <-  word ( "@" word )? {
              $$ = _text(); }

## CONTACT

Contact             <- ( STAR / (contact_param (COMMA contact_param)*) ) {
                        var idx, length;
                        length = data.multi_header.length;
                        for (idx = 0; idx < length; idx++) {
                          if (data.multi_header[idx]['parsed'] == null) {
                            $$ == null;
                            break;
                          }
                        }
                        if (data != null) {
                          $$ = data.multi_header;
                        } else {
                          $$ == -1;
                        }}

contact_param       <- (addr_spec / name_addr) (SEMI contact_params)* {
                        var header;
                        if(data.multi_header == null) data.multi_header = [];
                        try {
                          header = NameAddrHeader(data.uri, data.display_name, data.params);
                          data.uri = null;
                          data.display_name = null;
                          data.params = null;
                        } catch(e) {
                          header = null;
                        }
                        data.multi_header.add( { 'raw': _text(),
                                                 'parsed': header
                                                });}

name_addr           <- ( display_name )? LAQUOT SIP_URI RAQUOT

addr_spec           <- SIP_URI_noparams

display_name        <- (LWS*)? display_name: (token ( LWS token )* / quoted_string_clean) (LWS*)?  {
                        if (display_name is String) { // quoted_string_clean
                          data.display_name = display_name;
                          return display_name;
                        } else { // token ( LWS token )*
                          if(display_name[1] is List){
                            data.display_name = display_name[1].fold(display_name[0], (aac, next) => aac + next[0] + next[1]);
                          } else if(display_name[1] is String){
                            data.display_name = display_name[1];
                          }
                          return data.display_name;
                        }
                        }
                        ## The previous rule is corrected from RFC3261
                        ## See https:##www.rfc-editor.org/errata/eid5598

contact_params      <- c_p_q / c_p_expires / contact_extension

c_p_q               <- "q"i EQUAL q: qvalue {
                        if(data.params == null) data.params = {};
                        data.params['q'] = q; }

c_p_expires         <- "expires"i EQUAL expires: delta_seconds {
                        if(data.params == null) data.params = {};
                        data.params['expires'] = expires; }

contact_extension   <- generic_param

delta_seconds       <- delta_seconds: DIGIT+ {
                        return parseInt(delta_seconds.join('')); }

qvalue              <- "0" ( "." DIGIT? DIGIT? DIGIT? )? {
                        return parseFloat(_text()); }

generic_param       <- param: token  value: ( EQUAL gen_value )? {
                        if(data.params == null) data.params = {};
                        if (value != null) {
                          value = value[1];
                        }
                        if(param.toLowerCase() == 'branch'){
                          data.branch = value;
                        }
                        data.params[param.toLowerCase()] = value;}

gen_value           <- token / host / quoted_string


## CONTENT-DISPOSITION

Content_Disposition     <- disp_type ( SEMI disp_param )*

disp_type               <- "render"i / "session"i / "icon"i / "alert"i / disp_extension_token

disp_param              <- handling_param / generic_param

handling_param          <- "handling"i EQUAL ( "optional"i / "required"i / other_handling )

other_handling          <- token

disp_extension_token    <- token


## CONTENT-ENCODING

Content_Encoding    <- content_coding (COMMA content_coding)*

content_coding      <- token


## CONTENT-LENGTH

Content_Length      <- length: (DIGIT +) {
                        return parseInt(length.join('')); }

## CONTENT-TYPE

Content_Type        <- media_type  {
                        $$ = _text(); }

media_type          <- m_type SLASH m_subtype (SEMI m_parameter)*

m_type              <- discrete_type / composite_type

discrete_type       <- "text"i / "image"i / "audio"i / "video"i / "application"i / "message"i
                    / extension_token

composite_type      <- "message"i / "multipart"i / extension_token

extension_token     <- ietf_token / x_token

ietf_token          <- token

x_token             <- "x-"i token

m_subtype           <- extension_token / iana_token

iana_token          <- token

m_parameter         <- m_attribute EQUAL m_value

m_attribute         <- token

m_value             <- token / quoted_string


## CSEQ

CSeq          <- CSeq_value LWS CSeq_method {return data;}

CSeq_value    <- cseq_value: DIGIT + {
                  data.cseq = parseInt(cseq_value.join('')); }

CSeq_method   <- Method

## EXPIRES

Expires     <- expires: delta_seconds {data = expires; }

Event             <- event: event_type ( SEMI event_param )* {
                    data.event = event;
                    return data;
                  }

event_type        <- event_package ( "." event_template )* {return _text().toLowerCase();}

event_package     <- token_nodot

event_template    <- token_nodot

event_param       <- generic_param

## FROM

From        <- ( addr_spec / name_addr ) ( SEMI from_param )* {
                var tag = data.tag;
                try {
                  $$ = NameAddrHeader(data.uri, data.display_name, data.params);
                  if (tag != null) {$$.setParam('tag',tag);}
                } catch(e) {
                  $$ == -1;
                }}

from_param  <- (tag_param / generic_param)

tag_param   <- "tag"i EQUAL tag: token {data.tag = tag; }


## MAX-FORWARDS

Max_Forwards  <- forwards: DIGIT+ {
                  return parseInt(forwards.join('')); }


## MIN-EXPIRES

Min_Expires  <- min_expires: delta_seconds {data = min_expires; }

## Name_Addr

Name_Addr_Header <-  ( display_name )* LAQUOT SIP_URI RAQUOT ( SEMI generic_param )* {
                      try {
                        $$ = NameAddrHeader(data.uri, data.display_name, data.params);
                      } catch(e) {
                        $$ == -1;
                      }}

## PROXY-AUTHENTICATE

Proxy_Authenticate  <- proxy_authenticate: challenge

challenge           <- (("Digest"i LWS digest_cln (COMMA digest_cln)*)
                      / other_challenge) {return data;}

other_challenge     <- auth_scheme LWS  auth_param (COMMA auth_param)*
                      {return data;}

auth_scheme         <- token

auth_param          <- key: auth_param_name EQUAL value: ( token / quoted_string_clean ) {
                        // print('other_auth_param: ' + key + ' => ' + value);
                        if(data.auth_params == null) data.auth_params = {};
                        data.auth_params[key] = value;
                      }

auth_param_name     <- token

digest_cln          <- realm / domain / nonce / opaque / stale / algorithm / qop_options / auth_param

realm               <- "realm"i EQUAL realm_value

realm_value         <- realm: quoted_string_clean {
                      data.realm = realm;
                      return data.realm;}

domain              <- "domain"i EQUAL LDQUOT URI ( SP+ URI )* RDQUOT

URI                 <- absoluteURI / abs_path

nonce               <- "nonce"i EQUAL nonce_value

nonce_value         <- nonce: quoted_string_clean { data.nonce = nonce; return nonce; }

opaque              <- "opaque"i EQUAL opaque: quoted_string_clean { data.opaque = opaque; return opaque; }

stale               <- "stale"i EQUAL stale: token {
                      data.stale = stale.toLowerCase() == 'true';
                      return stale;}

algorithm           <- "algorithm"i EQUAL algorithm: ( "MD5"i / "MD5"i / "MD5-sess"i / token / quoted_string_clean) {
                      data.algorithm=algorithm.toUpperCase(); return data.algorithm;}

qop_options         <- "qop"i EQUAL LDQUOT (qop_value ("," qop_value)*) RDQUOT

qop_value           <- qop_value: ( "auth-int"i / "auth"i / token ) {
                        if(data.qop == null) data.qop=[];
                        data.qop.add(qop_value.toLowerCase());
                        return data.qop;
                      }


## PROXY-REQUIRE

Proxy_Require  <- option_tag (COMMA option_tag)*

option_tag     <- token


## RECORD-ROUTE

Record_Route  <- rec_route (COMMA rec_route)* {
                  var idx, length;
                  length = data.multi_header.length;
                  for (idx = 0; idx < length; idx++) {
                    if (data.multi_header[idx]['parsed'] == null) {
                      $$ = null;
                      break;
                    }
                  }
                  if(data.multi_header != null) {
                    $$ = data.multi_header;
                  } else {
                    $$ == -1;
                  }}

rec_route     <- (name_addr ( SEMI rr_param )*) {
                  var header;
                  if(data.multi_header == null) data.multi_header = [];
                  try {
                    header = NameAddrHeader(data.uri, data.display_name, data.params);
                    data.uri = null;
                    data.display_name = null;
                    data.params = null;
                  } catch(e) {
                    header = null;
                  }
                  data.multi_header.add( { 'raw': _text(),
                                           'parsed': header
                                          });}

rr_param      <- generic_param


## REASON

##Reason        <- ( "SIP"i / token ) ( SEMI "cause" EQUAL cause: DIGIT + )? ( SEMI "text" EQUAL text:  )? {
##  data.cause = cause;
##  data.text = text;
##}


## Reason        <- ( "SIP"i / token ) ( SEMI generic_param )*;


Reason        <- protocol: ( "SIP"i / token ) ( SEMI reason_param )* {
                  data.protocol = protocol.toLowerCase();
                  if (data.params == null) data.params = {};
                  if (data.params['text'] != null && data.params['text'][0] == '"') {
                    var text = data.params['text'];
                    data.text = text.substring(1, text.length-1);
                    data.params['text'] = null;
                  }
                  return data;
                }

reason_param  <- ( reason_cause / generic_param )

reason_cause  <- "cause"i EQUAL cause: DIGIT + {
                  data.cause = parseInt(cause.join(''));
                }


## REQUIRE

Require       <- option_tag (COMMA option_tag)*


## ROUTE

Route        <- route_param (COMMA route_param)*

route_param  <- name_addr ( SEMI rr_param )*


## SUBSCRIPTION-STATE

Subscription_State   <- substate_value ( SEMI subexp_params )*

substate_value       <- ( "active"i / "pending"i / "terminated"i
                       / extension_substate ) {
                        data.state = _text(); }

extension_substate   <- token

subexp_params        <- ("reason"i EQUAL reason: event_reason_value) {
                        if (reason != null) data.reason = reason; }
                       / ("expires"i EQUAL expires: delta_seconds) {
                        if (expires != null) data.expires = expires; }
                       / ("retry_after"i EQUAL retry_after: delta_seconds) {
                        if (retry_after != null) data.retry_after = retry_after; }
                       / generic_param

event_reason_value   <- "deactivated"i
                       / "probation"i
                       / "rejected"i
                       / "timeout"i
                       / "giveup"i
                       / "noresource"i
                       / "invariant"i
                       / event_reason_extension

event_reason_extension <- token


## SUBJECT

Subject  <- ( TEXT_UTF8_TRIM )?


## SUPPORTED

Supported  <- ( option_tag (COMMA option_tag)* )?


## TO

To         <- ( addr_spec / name_addr ) ( SEMI to_param )* {
              var tag = data.tag;
              try {
                $$ = NameAddrHeader(data.uri, data.display_name, data.params);
                if (tag != null) {$$.setParam('tag',tag);}
              } catch(e) {
                $$ = -1;
              }}

to_param   <- tag_param / generic_param

## VIA

Via        <- via_param (COMMA via_param)* {
               $$ = data;
             }

via_param         <- sent_protocol LWS sent_by ( SEMI via_params )*

via_params        <- via_ttl / via_maddr / via_received / via_branch / response_port / via_extension

via_ttl           <- "ttl"i EQUAL via_ttl_value: ttl {
                      data.ttl = via_ttl_value; }

via_maddr         <- "maddr"i EQUAL via_maddr: host {
                      data.maddr = via_maddr; }

via_received      <- "received"i EQUAL via_received: (IPv4address / IPv6address) {
                      data.received = via_received; }

via_branch        <- "branch"i EQUAL via_branch: token {
                      data.branch = via_branch;
                      return data.branch;
                    }

response_port     <- "rport"i EQUAL (response_port: (DIGIT ? DIGIT ? DIGIT ? DIGIT ? DIGIT ?) )? {
                      if(response_port != null) {
                        data.rport = parseInt(response_port.map((e) => e ?? '').join(''));
                      }
                    }


via_extension     <- generic_param

sent_protocol     <- protocol_name SLASH protocol_version SLASH transport

protocol_name     <- via_protocol: ( "SIP"i / token ) {
                      data.protocol = via_protocol;
                      return data.protocol;
                    }

protocol_version  <- token

transport         <- via_transport: ("UDP"i / "TCP"i / "TLS"i / "SCTP"i / other_transport) {
                      data.transport = via_transport; }

sent_by           <- via_host ( COLON via_port )?

via_host          <- ( IPv4address / IPv6reference / hostname ) {
                      data.host = _text(); }

via_port          <- via_sent_by_port: (DIGIT ? DIGIT ? DIGIT ? DIGIT ? DIGIT ?) {
                      data.port = parseInt(_text());
                      return data.port;
                    }

ttl               <- ttl: (DIGIT DIGIT ? DIGIT ?) {
                      return parseInt(ttl.join('')); }


## WWW-AUTHENTICATE

WWW_Authenticate  <- www_authenticate: challenge


## SESSION-EXPIRES

Session_Expires   <- s_e_expires ( SEMI s_e_params )* {
                        return data;}

s_e_expires       <- expires: delta_seconds { data.expires = expires; }

s_e_params        <- s_e_refresher / s_e_extension

s_e_refresher     <- "refresher"i EQUAL s_e_refresher_value: ( "uac"i / "uas"i ) { data.refresher = s_e_refresher_value.toLowerCase(); }

s_e_extension     <- generic_param


## EXTENSION-HEADER

extension_header  <- extension_header: header_name HCOLON header_value: header_value

header_name       <- token

header_value      <- (TEXT_UTF8char / UTF8_CONT / LWS)*

message_body      <- OCTET*


## UUID URI

uuid_URI      <- "uuid:" uuid
uuid          <- uuid: hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
                  data.uuid = _text();
                  $$ = data.uuid; }
hex4          <- HEXDIG HEXDIG HEXDIG HEXDIG
hex8          <- hex4 hex4
hex12         <- hex4 hex4 hex4


## Refer-To

Refer_To        <- ( addr_spec / name_addr ) ( SEMI generic_param )* {
                try {
                  $$ = NameAddrHeader(data.uri, data.display_name, data.params);
                } catch(e) {
                  $$ = -1;
                }}

## Replaces
Replaces        <- call_id: call_id (SEMI replaces_param)* {
                  return data;}

call_id          <-  word ( "@" word )? {
                  data.call_id = _text(); }

replaces_param  <- to_tag / from_tag / early_flag / generic_param

to_tag          <- "to-tag" EQUAL to_tag: token {
                    data.to_tag = to_tag; }

from_tag        <- "from-tag" EQUAL from_tag: token {
                    data.from_tag = from_tag; }

early_flag      <- "early-only" {
                    data.early_only = true; }
